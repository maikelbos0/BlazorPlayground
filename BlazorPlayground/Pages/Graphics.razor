@page "/graphics"
@using BlazorPlayground.Graphics
@using System.Globalization
@using System.Xml.Linq
@using System.Text
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<h1>Graphics</h1>

<ul class="nav nav-tabs mb-3">
    @foreach (var actionType in Enum.GetValues<ActionType>()) {
        <li class="nav-item">
            <a class="nav-link @(SelectedActionType == actionType ? "active" : "")" @onclick="() => SwitchActionType(actionType)">@actionDefinitions[actionType].Name</a>
        </li>
    }
</ul>

<div class="mb-3 graphics-ribbon">
    <div class="btn-toolbar">
        <div class="btn-group mb-3 me-3">
            <button type="button" class="btn btn-secondary" @onclick="Save">Save...</button>
        </div>

        <div class="input-group mb-3 me-3">
            <label for="fillColor" class="input-group-text">Fill</label>

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeColor" @onclick="() => FillPaintMode = PaintMode.Color" checked="@(FillPaintMode == PaintMode.Color)" />
                <label class="form-check-label ps-2" for="fillPaintModeColor">Color</label>
            </div>

            <input type="text" class="form-control" id="fillColor" style="background-color: @FillColorManager.Color; color: @FillColorManager.Color.ContrastingColor" @bind-value="FillColorManager.ColorValue" />

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeNone" @onclick="() => FillPaintMode = PaintMode.None" checked="@(FillPaintMode == PaintMode.None)" />
                <label class="form-check-label ps-2" for="fillPaintModeNone">None</label>
            </div>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyFill()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeColor" class="input-group-text">Stroke</label>

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeColor" @onclick="() => StrokePaintMode = PaintMode.Color" checked="@(StrokePaintMode == PaintMode.Color)" />
                <label class="form-check-label ps-2" for="strokePaintModeColor">Color</label>
            </div>

            <input type="text" class="form-control" id="strokeColor" style="background-color: @StrokeColorManager.Color; color: @StrokeColorManager.Color.ContrastingColor" @bind-value="StrokeColorManager.ColorValue" />

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeNone" @onclick="() => StrokePaintMode = PaintMode.None" checked="@(StrokePaintMode == PaintMode.None)" />
                <label class="form-check-label ps-2" for="strokePaintModeNone">None</label>
            </div>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStroke()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeWidth" class="input-group-text">Stroke width</label>
            <input type="text" class="form-control" id="strokeWidth" @bind-value="StrokeWidth" />

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeWidth()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeLinecap" class="input-group-text">Linecap</label>

            <select class="form-select" id="strokeLinecap" @bind="StrokeLinecap">
                @foreach (var linecap in Enum.GetValues<Linecap>()) {
                    <option value="@linecap">@linecap</option>
                }
            </select>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinecap()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeLinejoin" class="input-group-text">Linejoin</label>

            <select class="form-select" id="strokeLinejoin" @bind="StrokeLinejoin">
                @foreach (var linejoin in Enum.GetValues<Linejoin>()) {
                    <option value="@linejoin">@linejoin</option>
                }
            </select>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinejoin()">Apply</button>
            }
        </div>

        @if (SelectedActionType == ActionType.Select) {
            <div class="btn-group mb-3 me-3">
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(1)">Move forward</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToFrontOfList()">Move to front</button>
            </div>

            <div class="btn-group mb-3 me-3">
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToBackOfList()">Move to back</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(-1)">Move backward</button>
            </div>

            <div class="btn-group mb-3">
                <button type="button" class="btn btn-secondary" @onclick="DeleteSelected">Delete</button>
            </div>
        }
        else if (SelectedActionType == ActionType.DrawRegularPolygon) {
            <div class="input-group mb-3">
                <label for="regularPolygonSides" class="input-group-text">Sides</label>
                <input type="text" class="form-control" id="regularPolygonSides" @bind-value="RegularPolygonSides" />
            </div>
        }
        else if (SelectedActionType == ActionType.CanvasSettings) {
            <div class="input-group mb-3 me-3">
                <label for="canvasWidth" class="input-group-text">Width</label>
                <input type="text" class="form-control" id="canvasWidth" @bind-value="CanvasWidth" />
            </div>

            <div class="input-group mb-3 me-3">
                <label for="canvasHeight" class="input-group-text">Height</label>
                <input type="text" class="form-control" id="canvasHeight" @bind-value="CanvasHeight" />
            </div>

            <div class="input-group mb-3">
                <label for="gridSize" class="input-group-text">Grid size</label>
                <input type="text" class="form-control" id="gridSize" @bind-value="GridSize" />

                <div class="input-group-text">
                    <input class="form-check-input mt-0" type="checkbox" id="showGrid" @bind="ShowGrid" />
                    <label class="form-check-label ps-2" for="showGrid">Show</label>
                </div>

                <div class="input-group-text">
                    <input class="form-check-input mt-0" type="checkbox" id="snapToGrid" @bind="SnapToGrid" />
                    <label class="form-check-label ps-2" for="snapToGrid">Snap</label>
                </div>
            </div>
        }
    </div>
</div>

<svg class="graphics-main" viewBox="0 0 @CanvasWidth @CanvasHeight" width="@CanvasWidth" height="@CanvasHeight" @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnCanvasMouseUp">
    @if (ShowGrid) {
        for (var x = GridSize; x < CanvasWidth; x += GridSize) {
            <line class="grid-line" x1="@x" y1="0" x2="@x" y2="@CanvasHeight" />
        }

        for (var y = GridSize; y < CanvasHeight; y += GridSize) {
            <line class="grid-line" x1="0" y1="@y" x2="@CanvasWidth" y2="@y" />
        }
    }

    @foreach (var shape in Shapes) {
        if (shape == SelectedShape) {
            if (IsOperatingOnShape && IsSelected && IsDragging) {
                var changingShape = SelectedShape.Clone();

                if (IsOperatingOnAnchor) {
                    SelectedAnchor.Set(changingShape, SnappedEndPoint);
                }
                else {
                    changingShape.Transform(Delta, SnapToGrid, GridSize);
                }

                <ShapeRenderer Shape="changingShape" IsVirtual="true" />

                foreach (var anchor in changingShape.Anchors) {
                    var point = anchor.Get(changingShape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" />
                }
            }
            else {
                <ShapeRenderer @key="SelectedShape" Shape="SelectedShape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="true" />

                foreach (var anchor in SelectedShape.Anchors) {
                    var point = anchor.Get(SelectedShape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" @onmousedown="args => OnAnchorMouseDown(args, anchor)" />
                }
            }
        }
        else {
            <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="false" />
        }
    }

    @if (IsDragging && CurrentActionDefinition is DrawActionDefinition drawActionDefinition) {
        <ShapeRenderer Shape="CreateShape(drawActionDefinition.Constructor)" IsVirtual="true" />
    }
</svg>

@code {

    private enum ActionType {
        Select,
        DrawLine,
        DrawRectangle,
        DrawCircle,
        DrawEllipse,
        DrawRegularPolygon,
        DrawQuadraticBezier,
        DrawCubicBezier,
        CanvasSettings
    }

    private class ActionDefinition {
        public string Name { get; }
        public Action<Graphics> OnCanvasMouseUp { get; }
        public Action<Graphics, Shape> OnShapeMouseDown { get; }
        public Action<Graphics> OnSwitchFrom { get; }

        public ActionDefinition(string name,
            Action<Graphics> onCanvasMouseUp = null,
            Action<Graphics, Shape> onShapeMouseDown = null,
            Action<Graphics> onSwitchFrom = null
        ) {
            Name = name;
            OnCanvasMouseUp = onCanvasMouseUp ?? ((_) => { });
            OnShapeMouseDown = onShapeMouseDown ?? ((_, _) => { });
            OnSwitchFrom = onSwitchFrom ?? (_ => { });
        }
    }

    private class DrawActionDefinition : ActionDefinition {
        public Func<Graphics, Shape> Constructor { get; }

        public DrawActionDefinition(string name, Func<Graphics, Shape> constructor, bool autoSelect = false) : base(name, (graphics) => graphics.AddShape(constructor, autoSelect)) {
            Constructor = constructor;
        }
    }

    private enum PaintMode {
        None,
        Color
    }

    private static Dictionary<ActionType, ActionDefinition> actionDefinitions = new Dictionary<ActionType, ActionDefinition>() {
        { ActionType.Select, new ActionDefinition("Select", onCanvasMouseUp: (graphics) => graphics.ProcessSelection(), onShapeMouseDown: (graphics, shape) => graphics.Select(shape), onSwitchFrom: graphics => graphics.Deselect()) },
        { ActionType.DrawLine, new DrawActionDefinition("Line", (graphics) => new Line(graphics.SnappedStartPoint, graphics.SnappedEndPoint)) },
        { ActionType.DrawRectangle, new DrawActionDefinition("Rectangle", (graphics) => new Rectangle(graphics.SnappedStartPoint, graphics.SnappedEndPoint)) },
        { ActionType.DrawCircle, new DrawActionDefinition("Circle", (graphics) => new Circle(graphics.SnappedStartPoint, graphics.SnappedEndPoint)) },
        { ActionType.DrawEllipse, new DrawActionDefinition("Ellipse", (graphics) => new Ellipse(graphics.SnappedStartPoint, graphics.SnappedEndPoint)) },
        { ActionType.DrawRegularPolygon, new DrawActionDefinition("Regular polygon", (graphics) => new RegularPolygon(graphics.SnappedStartPoint, graphics.SnappedEndPoint, graphics.RegularPolygonSides)) },
        { ActionType.DrawQuadraticBezier, new DrawActionDefinition("Quadratic bezier", (graphics) => new QuadraticBezier(graphics.SnappedStartPoint, graphics.SnappedEndPoint), true) },
        { ActionType.DrawCubicBezier, new DrawActionDefinition("Cubic bezier", (graphics) => new CubicBezier(graphics.SnappedStartPoint, graphics.SnappedEndPoint), true) },
        { ActionType.CanvasSettings, new ActionDefinition("Canvas settings") }
    };

    // General
    private List<Shape> Shapes { get; } = new List<Shape>();
    private ActionType SelectedActionType { get; set; } = ActionType.DrawRegularPolygon;
    private IJSObjectReference moduleReference;

    // Coordinates
    private Point StartPoint { get; set; }
    private Point SnappedStartPoint => GetSnappedPoint(StartPoint);
    private Point EndPoint { get; set; }
    private Point SnappedEndPoint => GetSnappedPoint(EndPoint);
    private bool IsDragging => StartPoint != null && EndPoint != null;
    private Point Delta => EndPoint - StartPoint;

    // Selection
    private bool IsOperatingOnShape { get; set; } = false;
    private Shape SelectedShape { get; set; }
    private bool IsSelected => SelectedShape != null;
    private Anchor SelectedAnchor { get; set; }
    private bool IsOperatingOnAnchor => SelectedAnchor != null;

    private ActionDefinition CurrentActionDefinition => actionDefinitions[SelectedActionType];

    // Form fields
    private PaintMode FillPaintMode { get; set; } = PaintMode.None;

    private ColorManager FillColorManager { get; set; } = new ColorManager("#FFFFFF");

    private IPaintServer FillPaintServer => FillPaintMode switch {
        PaintMode.Color => FillColorManager.Color,
        PaintMode.None => PaintServer.None,
        _ => throw new NotImplementedException($"No implementation found for {nameof(PaintMode)} '{FillPaintMode}'")
    };

    private PaintMode StrokePaintMode { get; set; } = PaintMode.Color;

    private ColorManager StrokeColorManager { get; set; } = new ColorManager("#000000");

    private IPaintServer StrokePaintServer => StrokePaintMode switch {
        PaintMode.Color => StrokeColorManager.Color,
        PaintMode.None => PaintServer.None,
        _ => throw new NotImplementedException($"No implementation found for {nameof(PaintMode)} '{StrokePaintMode}'")
    };

    private Linecap StrokeLinecap { get; set; } = Linecap.Butt;

    private Linejoin StrokeLinejoin { get; set; } = Linejoin.Miter;

    private int strokeWidth = 1;
    private int StrokeWidth {
        get => strokeWidth;
        set => strokeWidth = Math.Max(value, 1);
    }

    private int regularPolygonSides = 3;
    private int RegularPolygonSides {
        get => regularPolygonSides;
        set => regularPolygonSides = Math.Max(value, 3);
    }

    private int canvasWidth = 800;
    private int CanvasWidth {
        get => canvasWidth;
        set => canvasWidth = Math.Max(value, 1);
    }

    private int canvasHeight = 800;
    private int CanvasHeight {
        get => canvasHeight;
        set => canvasHeight = Math.Max(value, 1);
    }

    private int gridSize = 50;
    private int GridSize {
        get => gridSize;
        set => gridSize = Math.Max(value, 1);
    }

    private bool ShowGrid { get; set; } = false;

    private bool SnapToGrid { get; set; } = false;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            moduleReference = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/downloadFile.js");
        }
    }

    public async ValueTask DisposeAsync() {
        if (moduleReference is not null) {
            await moduleReference.DisposeAsync();
        }
    }

    private void SwitchActionType(ActionType newActionType) {
        CurrentActionDefinition.OnSwitchFrom(this);
        SelectedActionType = newActionType;
    }

    private void OnCanvasMouseDown(MouseEventArgs args) {
        if (args.Button == 0) {
            StartPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs args) {
        if (args.Button == 0 && StartPoint != null) {
            EndPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs args) {
        if (args.Button == 0 && StartPoint != null) {
            CurrentActionDefinition.OnCanvasMouseUp(this);
        }

        StartPoint = null;
        EndPoint = null;
        SelectedAnchor = null;
        IsOperatingOnShape = false;
    }

    private void OnShapeMouseDown(MouseEventArgs args, Shape shape) {
        if (args.Button == 0) {
            CurrentActionDefinition.OnShapeMouseDown(this, shape);
        }
    }

    private void OnAnchorMouseDown(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            SelectedAnchor = anchor;
            IsOperatingOnShape = true;
        }
    }

    private Point GetSnappedPoint(Point point) {
        if (!SnapToGrid || point == null) {
            return point;
        }

        return point.SnapToGrid(GridSize);
    }

    private void AddShape(Func<Graphics, Shape> constructor, bool autoSelect) {
        if (IsDragging) {
            var shape = CreateShape(constructor);

            Shapes.Add(shape);

            if (autoSelect) {
                SwitchActionType(ActionType.Select);
                SelectedShape = shape;
            }
        }
    }

    private Shape CreateShape(Func<Graphics, Shape> constructor) {
        var shape = constructor(this);

        shape.Fill = FillPaintServer;
        shape.Stroke = StrokePaintServer;
        shape.StrokeWidth = StrokeWidth;
        shape.StrokeLinecap = StrokeLinecap;
        shape.StrokeLinejoin = StrokeLinejoin;

        return shape;
    }

    private void DeleteSelected() {
        if (SelectedShape != null) {
            Shapes.Remove(SelectedShape);
            SelectedShape = null;
        }
    }

    private void Select(Shape shape) {
        SelectedShape = shape;
        IsOperatingOnShape = true;
    }

    private void ProcessSelection() {
        if (IsOperatingOnShape) {
            if (IsSelected && IsDragging) {
                if (IsOperatingOnAnchor) {
                    SelectedAnchor.Set(SelectedShape, SnappedEndPoint);
                }
                else {
                    SelectedShape.Transform(Delta, SnapToGrid, GridSize);
                }
            }
        }
        else {
            SelectedShape = null;
        }
    }

    private void Deselect() {
        SelectedShape = null;
    }

    private void ApplyFill() {
        if (IsSelected) {
            SelectedShape.Fill = FillPaintServer;
        }
    }

    private void ApplyStroke() {
        if (IsSelected) {
            SelectedShape.Stroke = StrokePaintServer;
        }
    }

    private void ApplyStrokeLinecap() {
        if (IsSelected) {
            SelectedShape.StrokeLinecap = StrokeLinecap;
        }
    }


    private void ApplyStrokeLinejoin() {
        if (IsSelected) {
            SelectedShape.StrokeLinejoin = StrokeLinejoin;
        }
    }

    private void ApplyStrokeWidth() {
        if (IsSelected) {
            SelectedShape.StrokeWidth = StrokeWidth;
        }
    }

    private void MoveSelectedShapeToBackOfList() {
        if (IsSelected) {
            Shapes.Remove(SelectedShape);
            Shapes.Insert(0, SelectedShape);
        }
    }

    private void MoveSelectedShapeInList(int indexChange) {
        if (IsSelected) {
            var index = Shapes.IndexOf(SelectedShape);
            var newIndex = index + indexChange;

            if (newIndex > 0 && newIndex < Shapes.Count) {
                Shapes[index] = Shapes[newIndex];
                Shapes[newIndex] = SelectedShape;
            }
        }
    }

    private void MoveSelectedShapeToFrontOfList() {
        if (IsSelected) {
            Shapes.Remove(SelectedShape);
            Shapes.Add(SelectedShape);
        }
    }

    private async Task Save() {
        var element = new XElement(
            "svg",
            new XAttribute("viewBox", $"0 0 {CanvasWidth} {CanvasHeight}"),
            new XAttribute("width", CanvasWidth),
            new XAttribute("height", CanvasHeight)
        );

        element.Add(Shapes.Select(s => s.CreateElement()));

        await moduleReference.InvokeVoidAsync("downloadFile", $"graphics {DateTime.UtcNow:yyyyMMdd hhmm}.svg", "image/svg+xml", Encoding.UTF8.GetBytes(element.ToString()));
    }
}
