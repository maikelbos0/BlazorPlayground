@page "/graphics"
@using BlazorPlayground.Graphics
@using System.Globalization
@using System.Xml.Linq
@using System.Text
@using System.IO
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<h1>Graphics</h1>

<div class="modal graphics-modal @(ShowLoadModal ? "d-block" : "")" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Load file</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="() => ToggleLoadModal(false)"></button>
            </div>
            <div class="modal-body">
                <p>Please note that only valid SVG files can be parsed and only Canvas.Shapes written by this graphics module can be edited.</p>

                <label for="inputFileToLoad" class="form-label">SVG file</label>
                <InputFile id="inputFileToLoad" class="@(FileLoadHasError ? "form-control is-invalid" : "form-control")" OnChange="OnInputFileToLoadChange" />

                @if (FileLoadHasError) {
                    <div class="invalid-feedback">@FileLoadError</div>
                }
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" @onclick="Load">Load</button>
                <button type="button" class="btn btn-secondary" @onclick="() => ToggleLoadModal(false)">Cancel</button>
            </div>
        </div>
    </div>
</div>

<div class="btn-toolbar">
    <fieldset class="btn-group mb-3 me-3">
        <button type="button" class="btn btn-secondary" @onclick="() => Save()">Save</button>
        <button type="button" class="btn btn-secondary" @onclick="() => ToggleLoadModal(true)">Load</button>
    </fieldset>

    <fieldset class="input-group mb-3 me-3">
        <div class="input-group-text">
            <label for="canvasWidth">Canvas width</label>
        </div>
        
        <input type="text" class="form-control" id="canvasWidth" @bind-value="Canvas.Width" />
    </fieldset>

    <fieldset class="input-group mb-3 me-3">
        <div class="input-group-text">
            <label for="canvasHeight">Canvas height</label>
        </div>
        
        <input type="text" class="form-control" id="canvasHeight" @bind-value="Canvas.Height" />
    </fieldset>

    <fieldset class="input-group mb-3 me-3">
        <div class="input-group-text">
            <label for="gridSize">Grid size</label>
        </div>
        
        <input type="text" class="form-control" id="gridSize" @bind-value="Canvas.GridSize" />

        <div class="input-group-text">
            <input class="form-check-input mt-0" type="checkbox" id="showGrid" @bind="Canvas.ShowGrid" />
            <label class="form-check-label ps-2" for="showGrid">Show</label>
        </div>

        <div class="input-group-text">
            <input class="form-check-input mt-0" type="checkbox" id="snapToGrid" @bind="Canvas.SnapToGrid" />
            <label class="form-check-label ps-2" for="snapToGrid">Snap</label>
        </div>
    </fieldset>

    <fieldset class="input-group mb-3 me-3">
        <div class="input-group-text">
            <input class="form-check-input mt-0" type="radio" name="mode" id="modeSelect" @onclick="() => Canvas.StopDrawing()" checked="@(!Canvas.IsDrawing)" />
            <label class="form-check-label ps-2" for="modeSelect">Select</label>
        </div>

        @foreach (var definition in ShapeDefinition.Values) {
            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="mode" id="@("mode" + definition.Name)" @onclick="() => Canvas.StartDrawing(definition)" checked="@(Canvas.IsDrawing && Canvas.CurrentShapeDefinition == definition)" />
                <label class="form-check-label ps-2" for="@("mode" + definition.Name)">@definition.Name</label>
            </div>
        }
    </fieldset>

    <fieldset class="input-group mb-3 me-3" disabled="@(!Canvas.CurrentShapeDefinition.UseFill)">
        <div class="input-group-text">
            <label for="fillColor">Fill</label>
        </div>

        <div class="input-group-text">
            <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeColor" @onclick="() => Canvas.DrawSettings.FillPaintManager.Mode = PaintMode.Color" checked="@(Canvas.DrawSettings.FillPaintManager.Mode == PaintMode.Color)" />
            <label class="form-check-label ps-2" for="fillPaintModeColor">Color</label>
        </div>

        <input type="text" class="form-control" id="fillColor" style="background-color: @Canvas.DrawSettings.FillPaintManager.Color; color: @Canvas.DrawSettings.FillPaintManager.Color.ContrastingColor" @bind-value="Canvas.DrawSettings.FillPaintManager.ColorValue" />

        <div class="input-group-text">
            <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeNone" @onclick="() => Canvas.DrawSettings.FillPaintManager.Mode = PaintMode.None" checked="@(Canvas.DrawSettings.FillPaintManager.Mode == PaintMode.None)" />
            <label class="form-check-label ps-2" for="fillPaintModeNone">None</label>
        </div>

        <button type="button" class="btn btn-secondary" @onclick="() => ApplyFill()" disabled="@(Canvas.SelectedShape == null)">Apply</button>
    </fieldset>

    <fieldset class="input-group mb-3 me-3" disabled="@(!Canvas.CurrentShapeDefinition.UseStroke)">
        <div class="input-group-text">
            <label for="strokeColor">Stroke</label>
        </div>

        <div class="input-group-text">
            <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeColor" @onclick="() => Canvas.DrawSettings.StrokePaintManager.Mode = PaintMode.Color" checked="@(Canvas.DrawSettings.StrokePaintManager.Mode == PaintMode.Color)" />
            <label class="form-check-label ps-2" for="strokePaintModeColor">Color</label>
        </div>

        <input type="text" class="form-control" id="strokeColor" style="background-color: @Canvas.DrawSettings.StrokePaintManager.Color; color: @Canvas.DrawSettings.StrokePaintManager.Color.ContrastingColor" @bind-value="Canvas.DrawSettings.StrokePaintManager.ColorValue" />

        <div class="input-group-text">
            <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeNone" @onclick="() => Canvas.DrawSettings.StrokePaintManager.Mode = PaintMode.None" checked="@(Canvas.DrawSettings.StrokePaintManager.Mode == PaintMode.None)" />
            <label class="form-check-label ps-2" for="strokePaintModeNone">None</label>
        </div>

        <button type="button" class="btn btn-secondary" @onclick="() => ApplyStroke()" disabled="@(Canvas.SelectedShape == null)">Apply</button>
    </fieldset>

    <fieldset class="input-group mb-3 me-3" disabled="@(!Canvas.CurrentShapeDefinition.UseStrokeWidth)">
        <div class="input-group-text">
            <label for="strokeWidth">Stroke width</label>
        </div>
        
        <input type="text" class="form-control" id="strokeWidth" @bind-value="Canvas.DrawSettings.StrokeWidth" />

        <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeWidth()" disabled="@(Canvas.SelectedShape == null)">Apply</button>
    </fieldset>

    <fieldset class="input-group mb-3 me-3" disabled="@(!Canvas.CurrentShapeDefinition.UseStrokeLinecap)">
        <div class="input-group-text">
            <label for="strokeLinecap">Linecap</label>
        </div>

        <select class="form-select" id="strokeLinecap" @bind="Canvas.DrawSettings.StrokeLinecap">
            @foreach (var linecap in Enum.GetValues<Linecap>()) {
                <option value="@linecap">@linecap</option>
            }
        </select>

        <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinecap()" disabled="@(Canvas.SelectedShape == null)">Apply</button>
    </fieldset>

    <fieldset class="input-group mb-3 me-3" disabled="@(!Canvas.CurrentShapeDefinition.UseStrokeLinejoin)">
        <div class="input-group-text">
            <label for="strokeLinejoin">Linejoin</label>
        </div>

        <select class="form-select" id="strokeLinejoin" @bind="Canvas.DrawSettings.StrokeLinejoin">
            @foreach (var linejoin in Enum.GetValues<Linejoin>()) {
                <option value="@linejoin">@linejoin</option>
            }
        </select>

        <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinejoin()" disabled="@(Canvas.SelectedShape == null)">Apply</button>
    </fieldset>

    <fieldset class="input-group mb-3 me-3" disabled="@(!Canvas.CurrentShapeDefinition.UseSides)">
        <div class="input-group-text">
            <label for="sides">Sides</label>
        </div>

        <input type="text" class="form-control" id="sides" @bind-value="Canvas.DrawSettings.Sides" />

        <button type="button" class="btn btn-secondary" @onclick="() => ApplySides()" disabled="@(Canvas.SelectedShape == null)">Apply</button>
    </fieldset>

    <fieldset class="btn-group mb-3 me-3" disabled="@(Canvas.SelectedShape == null)">
        <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToFrontOfList()">Move to front</button>
        <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(1)">Move forward</button>
    </fieldset>

    <fieldset class="btn-group mb-3 me-3" disabled="@(Canvas.SelectedShape == null)">
        <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(-1)">Move backward</button>
        <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToBackOfList()">Move to back</button>
    </fieldset>

    <fieldset class="btn-group mb-3 me-3" disabled="@(Canvas.SelectedShape == null)">
        <button type="button" class="btn btn-secondary" @onclick="() => Canvas.DeleteSelectedShape()">Delete</button>
    </fieldset>
</div>

<svg class="graphics-main" viewBox="0 0 @Canvas.Width @Canvas.Height" width="@Canvas.Width" height="@Canvas.Height" @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnCanvasMouseUp">
    @if (Canvas.ShowGrid) {
        for (var x = Canvas.GridSize; x < Canvas.Width; x += Canvas.GridSize) {
            <line class="grid-line" x1="@x" y1="0" x2="@x" y2="@Canvas.Height" />
        }

        for (var y = Canvas.GridSize; y < Canvas.Height; y += Canvas.GridSize) {
            <line class="grid-line" x1="0" y1="@y" x2="@Canvas.Width" y2="@y" />
        }
    }

    @foreach (var shape in Canvas.Shapes) {
        if (shape == Canvas.SelectedShape) {
            if (Canvas.IsExecutingAction) {
                var virtualShape = Canvas.CreateVirtualSelectedShape();

                <ShapeRenderer Shape="virtualShape" IsVirtual="true" OnMouseUp="args => OnShapeMouseUp(args, shape)" />

                foreach (var anchor in virtualShape.Anchors) {
                    var point = anchor.Get(virtualShape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" @onmouseup="args => OnAnchorMouseUp(args, anchor)" @onmouseup:stopPropagation="true" />
                }
            }
            else {
                <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="true" OnMouseUp="args => OnShapeMouseUp(args, shape)" />

                foreach (var anchor in shape.Anchors) {
                    var point = anchor.Get(shape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" @onmousedown="args => OnAnchorMouseDown(args, anchor)" />
                }
            }
        }
        else {
            <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="false" />
        }
    }

    @if (Canvas.IsDrawing && Canvas.IsExecutingAction) {
        <ShapeRenderer Shape="Canvas.CreateShape()" IsVirtual="true" />
    }
</svg>

@code {
    private IJSObjectReference ModuleReference { get; set; }
    private bool ShowLoadModal { get; set; } = false;
    private string FileLoadError { get; set; }
    private bool FileLoadHasError => !string.IsNullOrWhiteSpace(FileLoadError);
    private IBrowserFile FileToLoad { get; set; }
    private string FileName { get; set; }
    private Canvas Canvas { get; set; } = new Canvas();

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            ModuleReference = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/downloadFile.js");
        }
    }

    public async ValueTask DisposeAsync() {
        if (ModuleReference is not null) {
            await ModuleReference.DisposeAsync();
        }
    }

    private void OnCanvasMouseDown(MouseEventArgs args) {
        if (args.Button == 0) {
            Canvas.StartPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs args) {
        if (args.Button == 0 && Canvas.StartPoint != null) {
            Canvas.EndPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs args) {
        if (args.Button == 0) {
            if (Canvas.IsDrawing && Canvas.IsExecutingAction) {
                Canvas.AddShape();
            }
            else {
                Canvas.SelectedShape = null;
            }

            Canvas.ClearActionExecution();
        }
    }

    private void OnShapeMouseDown(MouseEventArgs args, Shape shape) {
        if (!Canvas.IsDrawing && args.Button == 0) {
            // TODO set correct definition after selecting
            Canvas.SelectedShape = shape;
        }
    }

    private void OnShapeMouseUp(MouseEventArgs args, Shape shape) {
        if (args.Button == 0) {
            Canvas.TransformSelectedShape();
        }
    }

    private void OnAnchorMouseDown(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            Canvas.SelectedAnchor = anchor;
        }
    }

    // TODO if we're selecting a shape and the cursor falls on the anchor things get... weird
    private void OnAnchorMouseUp(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            Canvas.TransformSelectedShapeAnchor();
        }
    }

    private void ApplyFill() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.Fill = Canvas.DrawSettings.FillPaintManager.Server;
        }
    }

    private void ApplyStroke() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.Stroke = Canvas.DrawSettings.StrokePaintManager.Server;
        }
    }

    private void ApplyStrokeLinecap() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.StrokeLinecap = Canvas.DrawSettings.StrokeLinecap;
        }
    }

    private void ApplyStrokeLinejoin() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.StrokeLinejoin = Canvas.DrawSettings.StrokeLinejoin;
        }
    }

    private void ApplyStrokeWidth() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.StrokeWidth = Canvas.DrawSettings.StrokeWidth;
        }
    }

    private void ApplySides() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.Sides = Canvas.DrawSettings.Sides;
        }
    }

    private void MoveSelectedShapeToBackOfList() {
        if (Canvas.SelectedShape != null) {
            Canvas.Shapes.Remove(Canvas.SelectedShape);
            Canvas.Shapes.Insert(0, Canvas.SelectedShape);
        }
    }

    private void MoveSelectedShapeInList(int indexChange) {
        if (Canvas.SelectedShape != null) {
            var index = Canvas.Shapes.IndexOf(Canvas.SelectedShape);
            var newIndex = index + indexChange;

            if (newIndex > 0 && newIndex < Canvas.Shapes.Count) {
                Canvas.Shapes[index] = Canvas.Shapes[newIndex];
                Canvas.Shapes[newIndex] = Canvas.SelectedShape;
            }
        }
    }

    private void MoveSelectedShapeToFrontOfList() {
        if (Canvas.SelectedShape != null) {
            Canvas.Shapes.Remove(Canvas.SelectedShape);
            Canvas.Shapes.Add(Canvas.SelectedShape);
        }
    }

    private async Task Save() {
        var element = Canvas.ExportSvg();

        await ModuleReference.InvokeVoidAsync("downloadFile", FileName ?? $"graphics {DateTime.UtcNow:yyyyMMdd hhmm}.svg", "image/svg+xml", Encoding.UTF8.GetBytes(element.ToString()));
    }

    private void ToggleLoadModal(bool showLoadModal) {
        ShowLoadModal = showLoadModal;
        FileLoadError = null;
        FileToLoad = null;
    }

    private void OnInputFileToLoadChange(InputFileChangeEventArgs e) {
        // TODO clear input as well
        FileToLoad = e.File;
    }

    private async Task Load() {
        if (FileToLoad == null) {
            FileLoadError = "Please provide a valid SVG file.";
            return;
        }

        var data = await new StreamReader(FileToLoad.OpenReadStream()).ReadToEndAsync();
        var deserializationResult = SvgFileParser.Parse(data);

        if (deserializationResult.IsSuccess) {
            FileName = Path.GetFileName(FileToLoad.Name);
            Canvas = deserializationResult.Canvas;
            ToggleLoadModal(false);
        }
        else {
            FileLoadError = deserializationResult.ErrorMessage;
        }
    }
}
