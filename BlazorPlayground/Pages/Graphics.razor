@page "/graphics"
@using BlazorPlayground.Graphics

<h1>Graphics</h1>

<ul class="nav nav-tabs mb-3">
    @foreach (var actionType in Enum.GetValues<ActionType>()) {
        <li class="nav-item">
            <a class="nav-link @(SelectedActionType == actionType ? "active" : "")" @onclick="() => SwitchActionType(actionType)">@actionDefinitions[actionType].Name</a>
        </li>
    }
</ul>

<div class="mb-3 graphics-ribbon">
    <div class="btn-toolbar">
        <div class="input-group mb-3 me-3">
            <label for="strokeWidth" class="input-group-text">Stroke width</label>
            <input type="text" class="form-control" id="strokeWidth" @bind-value="StrokeWidth" />

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeWidth()">Apply</button>
            }
        </div>

        @if (SelectedActionType == ActionType.Select) {
            <div class="btn-group mb-3">
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToBackOfList()">Move to back</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(-1)">Move backward</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(1)">Move forward</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToFrontOfList()">Move to front</button>
                <button type="button" class="btn btn-secondary" @onclick="DeleteSelected">Delete</button>
            </div>
        }
        else if (SelectedActionType == ActionType.DrawRegularPolygon) {
            <div class="input-group mb-3">
                <label for="regularPolygonSides" class="input-group-text">Sides</label>
                <input type="text" class="form-control" id="regularPolygonSides" @bind-value="RegularPolygonSides" />
            </div>
        }
        else if (SelectedActionType == ActionType.CanvasSettings) {
            <div class="input-group mb-3 me-3">
                <label for="canvasWidth" class="input-group-text">Width</label>
                <input type="text" class="form-control" id="canvasWidth" @bind-value="CanvasWidth" />
            </div>

            <div class="input-group mb-3 me-3">
                <label for="canvasHeight" class="input-group-text">Height</label>
                <input type="text" class="form-control" id="canvasHeight" @bind-value="CanvasHeight" />
            </div>

            <div class="input-group mb-3">
                <label for="gridSize" class="input-group-text">Grid size</label>
                <input type="text" class="form-control" id="gridSize" @bind-value="GridSize" />

                <div class="input-group-text">
                    <input class="form-check-input mt-0" type="checkbox" id="showGrid" @bind="ShowGrid">
                    <label class="form-check-label ps-2" for="showGrid">Show</label>
                </div>

                <div class="input-group-text">
                    <input class="form-check-input mt-0" type="checkbox" id="snapToGrid" @bind="SnapToGrid">
                    <label class="form-check-label ps-2" for="snapToGrid">Snap</label>
                </div>
            </div>
        }
    </div>
</div>

<svg class="graphics-main" viewBox="0 0 @CanvasWidth @CanvasHeight" style="width: @(CanvasWidth)px; height: @(CanvasHeight)px" @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnCanvasMouseUp">
    @if (ShowGrid) {
        for (var x = GridSize; x < CanvasWidth; x += GridSize) {
            <line class="grid-line" x1="@x" y1="0" x2="@x" y2="@CanvasHeight" />
        }

        for (var y = GridSize; y < CanvasHeight; y += GridSize) {
            <line class="grid-line" x1="0" y1="@y" x2="@CanvasWidth" y2="@y" />
        }
    }

    @foreach (var shape in Shapes) {
        if (shape == SelectedShape) {
            if (IsOperatingOnShape && IsSelected && IsDragging) {
                var changingShape = SelectedShape.Clone();

                if (IsOperatingOnAnchor) {
                    SelectedAnchor.Set(changingShape, SnappedEndPoint);
                }
                else {
                    changingShape.Transform(Delta, SnapToGrid, GridSize);
                }

                <ShapeRenderer Shape="changingShape" IsVirtual="true" />

                foreach (var anchor in changingShape.Anchors) {
                    var point = anchor.Get(changingShape);

                    <rect class="shape-anchor" x="@(point.X - 5)" y="@(point.Y - 5)" width="10" height="10" />
                }
            }
            else {
                <ShapeRenderer @key="SelectedShape" Shape="SelectedShape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="true" />

                foreach (var anchor in SelectedShape.Anchors) {
                    var point = anchor.Get(SelectedShape);

                    <rect class="shape-anchor" x="@(point.X - 5)" y="@(point.Y - 5)" width="10" height="10" @onmousedown="args => OnAnchorMouseDown(args, anchor)" />
                }
            }
        }
        else {
            <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="false" />
        }
    }

    @if (IsDragging && CurrentActionDefinition is DrawActionDefinition drawActionDefinition) {
        <ShapeRenderer Shape="CreateShape(drawActionDefinition.Constructor)" IsVirtual="true" />
    }
</svg>

@code {

    private enum ActionType {
        Select,
        DrawLine,
        DrawRectangle,
        DrawCircle,
        DrawRegularPolygon,
        CanvasSettings
    }

    private class ActionDefinition {
        public string Name { get; }
        public Action<Graphics> OnCanvasMouseUp { get; }
        public Action<Graphics, Shape> OnShapeMouseDown { get; }
        public Action<Graphics> OnSwitchFrom { get; }

        public ActionDefinition(string name,
            Action<Graphics> onCanvasMouseUp = null,
            Action<Graphics, Shape> onShapeMouseDown = null,
            Action<Graphics> onSwitchFrom = null
        ) {
            Name = name;
            OnCanvasMouseUp = onCanvasMouseUp ?? ((_) => { });
            OnShapeMouseDown = onShapeMouseDown ?? ((_, _) => { });
            OnSwitchFrom = onSwitchFrom ?? (_ => { });
        }
    }

    private class DrawActionDefinition : ActionDefinition {
        public Func<Graphics, Shape> Constructor { get; }

        public DrawActionDefinition(string name, Func<Graphics, Shape> constructor) : base(name, (graphics) => graphics.AddShape(constructor)) {
            Constructor = constructor;
        }
    }

    private static Dictionary<ActionType, ActionDefinition> actionDefinitions = new Dictionary<ActionType, ActionDefinition>() {
        { ActionType.Select, new ActionDefinition("Select", onCanvasMouseUp: (graphics) => graphics.ProcessSelection(), onShapeMouseDown: (graphics, shape) => graphics.Select(shape), onSwitchFrom: graphics => graphics.Deselect()) },
        { ActionType.DrawLine, new DrawActionDefinition("Line", (graphics) => new Line(graphics.SnappedStartPoint, graphics.SnappedEndPoint)) },
        { ActionType.DrawRectangle, new DrawActionDefinition("Rectangle", (graphics) => new Rectangle(graphics.SnappedStartPoint, graphics.SnappedEndPoint)) },
        { ActionType.DrawCircle, new DrawActionDefinition("Circle", (graphics) => new Circle(graphics.SnappedStartPoint, graphics.SnappedEndPoint)) },
        { ActionType.DrawRegularPolygon, new DrawActionDefinition("Regular polygon", (graphics) => new RegularPolygon(graphics.SnappedStartPoint, graphics.SnappedEndPoint, graphics.RegularPolygonSides)) },
        { ActionType.CanvasSettings, new ActionDefinition("Canvas settings") }
    };

    // General
    private List<Shape> Shapes { get; } = new List<Shape>();
    private ActionType SelectedActionType { get; set; } = ActionType.DrawRegularPolygon;

    // Coordinates
    private Point StartPoint { get; set; }
    private Point SnappedStartPoint => GetSnappedPoint(StartPoint);
    private Point EndPoint { get; set; }
    private Point SnappedEndPoint => GetSnappedPoint(EndPoint);
    private bool IsDragging => StartPoint != null && EndPoint != null;
    private Point Delta => EndPoint - StartPoint;

    // Selection
    private bool IsOperatingOnShape { get; set; } = false;
    private Shape SelectedShape { get; set; }
    private bool IsSelected => SelectedShape != null;
    private Anchor SelectedAnchor { get; set; }
    private bool IsOperatingOnAnchor => SelectedAnchor != null;

    private ActionDefinition CurrentActionDefinition => actionDefinitions[SelectedActionType];

    // Form fields
    private int strokeWidth = 1;
    private int StrokeWidth {
        get => strokeWidth;
        set => strokeWidth = Math.Max(value, 1);
    }

    private int regularPolygonSides = 3;
    private int RegularPolygonSides {
        get => regularPolygonSides;
        set => regularPolygonSides = Math.Max(value, 3);
    }

    private int canvasWidth = 800;
    private int CanvasWidth {
        get => canvasWidth;
        set => canvasWidth = Math.Max(value, 1);
    }

    private int canvasHeight = 800;
    private int CanvasHeight {
        get => canvasHeight;
        set => canvasHeight = Math.Max(value, 1);
    }

    private int gridSize = 50;
    private int GridSize {
        get => gridSize;
        set => gridSize = Math.Max(value, 1);
    }

    private bool ShowGrid { get; set; } = false;

    private bool SnapToGrid { get; set; } = false;

    private void SwitchActionType(ActionType newActionType) {
        CurrentActionDefinition.OnSwitchFrom(this);
        SelectedActionType = newActionType;
    }

    private void OnCanvasMouseDown(MouseEventArgs args) {
        if (args.Button == 0) {
            StartPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs args) {
        if (args.Button == 0 && StartPoint != null) {
            EndPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs args) {
        if (args.Button == 0 && StartPoint != null) {
            CurrentActionDefinition.OnCanvasMouseUp(this);
        }

        StartPoint = null;
        EndPoint = null;
        SelectedAnchor = null;
        IsOperatingOnShape = false;
    }

    private void OnShapeMouseDown(MouseEventArgs args, Shape shape) {
        if (args.Button == 0) {
            CurrentActionDefinition.OnShapeMouseDown(this, shape);
        }
    }

    private void OnAnchorMouseDown(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            SelectedAnchor = anchor;
            IsOperatingOnShape = true;
        }
    }

    private Point GetSnappedPoint(Point point) {
        if (!SnapToGrid || point == null) {
            return point;
        }

        return point.SnapToGrid(GridSize);
    }

    private void AddShape(Func<Graphics, Shape> constructor) {
        if (IsDragging) {
            Shapes.Add(CreateShape(constructor));
        }
    }

    private Shape CreateShape(Func<Graphics, Shape> constructor) {
        var shape = constructor(this);

        shape.StrokeWidth = StrokeWidth;
        return shape;
    }

    private void DeleteSelected() {
        if (SelectedShape != null) {
            Shapes.Remove(SelectedShape);
            SelectedShape = null;
        }
    }

    private void Select(Shape shape) {
        SelectedShape = shape;
        IsOperatingOnShape = true;
    }

    private void ProcessSelection() {
        if (IsOperatingOnShape) {
            if (IsSelected && IsDragging) {
                if (IsOperatingOnAnchor) {
                    SelectedAnchor.Set(SelectedShape, SnappedEndPoint);
                }
                else {
                    SelectedShape.Transform(Delta, SnapToGrid, GridSize);
                }
            }
        }
        else {
            SelectedShape = null;
        }
    }

    private void Deselect() {
        SelectedShape = null;
    }

    private void ApplyStrokeWidth() {
        if (IsSelected) {
            SelectedShape.StrokeWidth = StrokeWidth;
        }
    }

    private void MoveSelectedShapeToBackOfList() {
        if (IsSelected) {
            Shapes.Remove(SelectedShape);
            Shapes.Insert(0, SelectedShape);
        }
    }

    private void MoveSelectedShapeInList(int indexChange) {
        if (IsSelected) {
            var index = Shapes.IndexOf(SelectedShape);
            var newIndex = index + indexChange;

            if (newIndex > 0 && newIndex < Shapes.Count) {
                Shapes[index] = Shapes[newIndex];
                Shapes[newIndex] = SelectedShape;
            }
        }
    }

    private void MoveSelectedShapeToFrontOfList() {
        if (IsSelected) {
            Shapes.Remove(SelectedShape);
            Shapes.Add(SelectedShape);
        }
    }

}
