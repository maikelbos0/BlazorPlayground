@page "/graphics"
@using BlazorPlayground.Graphics
@using System.Globalization
@using System.Xml.Linq
@using System.Text
@using System.IO
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<h1>Graphics</h1>

<ul class="nav nav-tabs mb-3">
    @foreach (var actionType in Enum.GetValues<ActionType>()) {
        <li class="nav-item">
            <a class="nav-link @(SelectedActionType == actionType ? "active" : "")" @onclick="() => SwitchActionType(actionType)">@actionDefinitions[actionType].Name</a>
        </li>
    }
</ul>

<div class="modal graphics-modal @(ShowLoadModal ? "d-block" : "")" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Load file</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="() => ToggleLoadModal(false)"></button>
            </div>
            <div class="modal-body">
                <p>Please note that only valid SVG files can be parsed and only Canvas.Shapes written by this graphics module can be edited.</p>

                <label for="inputFileToLoad" class="form-label">SVG file</label>
                <InputFile id="inputFileToLoad" class="@(FileLoadHasError ? "form-control is-invalid" : "form-control")" OnChange="OnInputFileToLoadChange" />

                @if (FileLoadHasError) {
                    <div class="invalid-feedback">@FileLoadError</div>
                }
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" @onclick="Load">Load</button>
                <button type="button" class="btn btn-secondary" @onclick="() => ToggleLoadModal(false)">Cancel</button>
            </div>
        </div>
    </div>
</div>

<div class="mb-3 graphics-ribbon">
    <div class="btn-toolbar">
        <div class="btn-group mb-3 me-3">
            <button type="button" class="btn btn-secondary" @onclick="Save">Save</button>
            <button type="button" class="btn btn-secondary" @onclick="() => ToggleLoadModal(true)">Load</button>
        </div>

        <div class="input-group mb-3 me-3">
            <label for="fillColor" class="input-group-text">Fill</label>

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeColor" @onclick="() => FillPaintManager.Mode = PaintMode.Color" checked="@(FillPaintManager.Mode == PaintMode.Color)" />
                <label class="form-check-label ps-2" for="fillPaintModeColor">Color</label>
            </div>

            <input type="text" class="form-control" id="fillColor" style="background-color: @FillPaintManager.Color; color: @FillPaintManager.Color.ContrastingColor" @bind-value="FillPaintManager.ColorValue" />

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeNone" @onclick="() => FillPaintManager.Mode = PaintMode.None" checked="@(FillPaintManager.Mode == PaintMode.None)" />
                <label class="form-check-label ps-2" for="fillPaintModeNone">None</label>
            </div>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyFill()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeColor" class="input-group-text">Stroke</label>

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeColor" @onclick="() => StrokePaintManager.Mode = PaintMode.Color" checked="@(StrokePaintManager.Mode == PaintMode.Color)" />
                <label class="form-check-label ps-2" for="strokePaintModeColor">Color</label>
            </div>

            <input type="text" class="form-control" id="strokeColor" style="background-color: @StrokePaintManager.Color; color: @StrokePaintManager.Color.ContrastingColor" @bind-value="StrokePaintManager.ColorValue" />

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeNone" @onclick="() => StrokePaintManager.Mode = PaintMode.None" checked="@(StrokePaintManager.Mode == PaintMode.None)" />
                <label class="form-check-label ps-2" for="strokePaintModeNone">None</label>
            </div>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStroke()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeWidth" class="input-group-text">Stroke width</label>
            <input type="text" class="form-control" id="strokeWidth" @bind-value="StrokeWidth" />

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeWidth()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeLinecap" class="input-group-text">Linecap</label>

            <select class="form-select" id="strokeLinecap" @bind="StrokeLinecap">
                @foreach (var linecap in Enum.GetValues<Linecap>()) {
                    <option value="@linecap">@linecap</option>
                }
            </select>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinecap()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeLinejoin" class="input-group-text">Linejoin</label>

            <select class="form-select" id="strokeLinejoin" @bind="StrokeLinejoin">
                @foreach (var linejoin in Enum.GetValues<Linejoin>()) {
                    <option value="@linejoin">@linejoin</option>
                }
            </select>

            @if (SelectedActionType == ActionType.Select) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinejoin()">Apply</button>
            }
        </div>

        @if (SelectedActionType == ActionType.Select) {
            <div class="btn-group mb-3 me-3">
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToFrontOfList()">Move to front</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(1)">Move forward</button>
            </div>

            <div class="btn-group mb-3 me-3">
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(-1)">Move backward</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToBackOfList()">Move to back</button>
            </div>

            <div class="btn-group mb-3">
                <button type="button" class="btn btn-secondary" @onclick="DeleteSelected">Delete</button>
            </div>
        }
        else if (SelectedActionType == ActionType.DrawRegularPolygon) {
            <div class="input-group mb-3">
                <label for="regularPolygonSides" class="input-group-text">Sides</label>
                <input type="text" class="form-control" id="regularPolygonSides" @bind-value="RegularPolygonSides" />
            </div>
        }
        else if (SelectedActionType == ActionType.CanvasSettings) {
            <div class="input-group mb-3 me-3">
                <label for="canvasWidth" class="input-group-text">Width</label>
                <input type="text" class="form-control" id="canvasWidth" @bind-value="Canvas.Width" />
            </div>

            <div class="input-group mb-3 me-3">
                <label for="canvasHeight" class="input-group-text">Height</label>
                <input type="text" class="form-control" id="canvasHeight" @bind-value="Canvas.Height" />
            </div>

            <div class="input-group mb-3">
                <label for="gridSize" class="input-group-text">Grid size</label>
                <input type="text" class="form-control" id="gridSize" @bind-value="Canvas.GridSize" />

                <div class="input-group-text">
                    <input class="form-check-input mt-0" type="checkbox" id="showGrid" @bind="Canvas.ShowGrid" />
                    <label class="form-check-label ps-2" for="showGrid">Show</label>
                </div>

                <div class="input-group-text">
                    <input class="form-check-input mt-0" type="checkbox" id="snapToGrid" @bind="Canvas.SnapToGrid" />
                    <label class="form-check-label ps-2" for="snapToGrid">Snap</label>
                </div>
            </div>
        }
    </div>
</div>

<svg class="graphics-main" viewBox="0 0 @Canvas.Width @Canvas.Height" width="@Canvas.Width" height="@Canvas.Height" @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnCanvasMouseUp">
    @if (Canvas.ShowGrid) {
        for (var x = Canvas.GridSize; x < Canvas.Width; x += Canvas.GridSize) {
            <line class="grid-line" x1="@x" y1="0" x2="@x" y2="@Canvas.Height" />
        }

        for (var y = Canvas.GridSize; y < Canvas.Height; y += Canvas.GridSize) {
            <line class="grid-line" x1="0" y1="@y" x2="@Canvas.Width" y2="@y" />
        }
    }

    @foreach (var shape in Canvas.Shapes) {
        if (shape == SelectedShape) {
            if (IsOperatingOnShape && IsSelected && Canvas.IsDragging) {
                var changingShape = SelectedShape.Clone();

                if (IsOperatingOnAnchor) {
                    SelectedAnchor.Set(changingShape, Canvas.SnappedEndPoint);
                }
                else {
                    changingShape.Transform(Canvas.Delta, Canvas.SnapToGrid, Canvas.GridSize);
                }

                <ShapeRenderer Shape="changingShape" IsVirtual="true" />

                foreach (var anchor in changingShape.Anchors) {
                    var point = anchor.Get(changingShape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" />
                }
            }
            else {
                <ShapeRenderer @key="SelectedShape" Shape="SelectedShape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="true" />

                foreach (var anchor in SelectedShape.Anchors) {
                    var point = anchor.Get(SelectedShape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" @onmousedown="args => OnAnchorMouseDown(args, anchor)" />
                }
            }
        }
        else {
            <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="false" />
        }
    }

    @if (Canvas.IsDragging && CurrentActionDefinition is DrawActionDefinition drawActionDefinition) {
        <ShapeRenderer Shape="CreateShape(drawActionDefinition.Constructor)" IsVirtual="true" />
    }
</svg>

@code {

    private enum ActionType {
        Select,
        DrawLine,
        DrawRectangle,
        DrawCircle,
        DrawEllipse,
        DrawRegularPolygon,
        DrawQuadraticBezier,
        DrawCubicBezier,
        CanvasSettings
    }

    private class ActionDefinition {
        public string Name { get; }
        public Action<Graphics> OnCanvasMouseUp { get; }
        public Action<Graphics, Shape> OnShapeMouseDown { get; }
        public Action<Graphics> OnSwitchFrom { get; }

        public ActionDefinition(string name,
            Action<Graphics> onCanvasMouseUp = null,
            Action<Graphics, Shape> onShapeMouseDown = null,
            Action<Graphics> onSwitchFrom = null
        ) {
            Name = name;
            OnCanvasMouseUp = onCanvasMouseUp ?? ((_) => { });
            OnShapeMouseDown = onShapeMouseDown ?? ((_, _) => { });
            OnSwitchFrom = onSwitchFrom ?? (_ => { });
        }
    }

    private class DrawActionDefinition : ActionDefinition {
        public Func<Graphics, Shape> Constructor { get; }

        public DrawActionDefinition(string name, Func<Graphics, Shape> constructor, bool autoSelect = false) : base(name, (graphics) => graphics.AddShape(constructor, autoSelect)) {
            Constructor = constructor;
        }
    }
    private static Dictionary<ActionType, ActionDefinition> actionDefinitions = new Dictionary<ActionType, ActionDefinition>() {
        { ActionType.Select, new ActionDefinition("Select", onCanvasMouseUp: (graphics) => graphics.ProcessSelection(), onShapeMouseDown: (graphics, shape) => graphics.Select(shape), onSwitchFrom: graphics => graphics.Deselect()) },
        { ActionType.DrawLine, new DrawActionDefinition("Line", (graphics) => new Line(graphics.Canvas.SnappedStartPoint, graphics.Canvas.SnappedEndPoint)) },
        { ActionType.DrawRectangle, new DrawActionDefinition("Rectangle", (graphics) => new Rectangle(graphics.Canvas.SnappedStartPoint, graphics.Canvas.SnappedEndPoint)) },
        { ActionType.DrawCircle, new DrawActionDefinition("Circle", (graphics) => new Circle(graphics.Canvas.SnappedStartPoint, graphics.Canvas.SnappedEndPoint)) },
        { ActionType.DrawEllipse, new DrawActionDefinition("Ellipse", (graphics) => new Ellipse(graphics.Canvas.SnappedStartPoint, graphics.Canvas.SnappedEndPoint)) },
        { ActionType.DrawRegularPolygon, new DrawActionDefinition("Regular polygon", (graphics) => new RegularPolygon(graphics.Canvas.SnappedStartPoint, graphics.Canvas.SnappedEndPoint, graphics.RegularPolygonSides)) },
        { ActionType.DrawQuadraticBezier, new DrawActionDefinition("Quadratic bezier", (graphics) => new QuadraticBezier(graphics.Canvas.SnappedStartPoint, graphics.Canvas.SnappedEndPoint), true) },
        { ActionType.DrawCubicBezier, new DrawActionDefinition("Cubic bezier", (graphics) => new CubicBezier(graphics.Canvas.SnappedStartPoint, graphics.Canvas.SnappedEndPoint), true) },
        { ActionType.CanvasSettings, new ActionDefinition("Canvas settings") }
    };

    // General
    private ActionType SelectedActionType { get; set; } = ActionType.DrawRegularPolygon;
    private IJSObjectReference ModuleReference { get; set; }
    private bool ShowLoadModal { get; set; } = false;
    private string FileLoadError { get; set; }
    private bool FileLoadHasError => !string.IsNullOrWhiteSpace(FileLoadError);
    private IBrowserFile FileToLoad { get; set; }
    private string FileName { get; set; }

    // Selection
    private bool IsOperatingOnShape { get; set; } = false;
    private Shape SelectedShape { get; set; }
    private bool IsSelected => SelectedShape != null;
    private Anchor SelectedAnchor { get; set; }
    private bool IsOperatingOnAnchor => SelectedAnchor != null;

    private ActionDefinition CurrentActionDefinition => actionDefinitions[SelectedActionType];

    // Form fields
    private PaintManager FillPaintManager { get; set; } = new PaintManager() { Mode = PaintMode.None, ColorValue = "#FFFFFF" };

    private PaintManager StrokePaintManager { get; set; } = new PaintManager() { Mode = PaintMode.Color, ColorValue = "#000000" };

    private Linecap StrokeLinecap { get; set; } = Linecap.Butt;

    private Linejoin StrokeLinejoin { get; set; } = Linejoin.Miter;

    private int strokeWidth = 1;
    private int StrokeWidth {
        get => strokeWidth;
        set => strokeWidth = Math.Max(value, 1);
    }

    private int regularPolygonSides = 3;
    private int RegularPolygonSides {
        get => regularPolygonSides;
        set => regularPolygonSides = Math.Max(value, 3);
    }

    private Canvas Canvas { get; set; } = new Canvas();

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            ModuleReference = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/downloadFile.js");
        }
    }

    public async ValueTask DisposeAsync() {
        if (ModuleReference is not null) {
            await ModuleReference.DisposeAsync();
        }
    }

    private void SwitchActionType(ActionType newActionType) {
        CurrentActionDefinition.OnSwitchFrom(this);
        SelectedActionType = newActionType;
    }

    private void OnCanvasMouseDown(MouseEventArgs args) {
        if (args.Button == 0) {
            Canvas.StartPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs args) {
        if (args.Button == 0 && Canvas.StartPoint != null) {
            Canvas.EndPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs args) {
        if (args.Button == 0 && Canvas.StartPoint != null) {
            CurrentActionDefinition.OnCanvasMouseUp(this);
        }

        Canvas.StartPoint = null;
        Canvas.EndPoint = null;
        SelectedAnchor = null;
        IsOperatingOnShape = false;
    }

    private void OnShapeMouseDown(MouseEventArgs args, Shape shape) {
        if (args.Button == 0) {
            CurrentActionDefinition.OnShapeMouseDown(this, shape);
        }
    }

    private void OnAnchorMouseDown(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            SelectedAnchor = anchor;
            IsOperatingOnShape = true;
        }
    }

    private void AddShape(Func<Graphics, Shape> constructor, bool autoSelect) {
        if (Canvas.IsDragging) {
            var shape = CreateShape(constructor);

            Canvas.Shapes.Add(shape);

            if (autoSelect) {
                SwitchActionType(ActionType.Select);
                SelectedShape = shape;
            }
        }
    }

    private Shape CreateShape(Func<Graphics, Shape> constructor) {
        var shape = constructor(this);

        shape.Fill = FillPaintManager.Server;
        shape.Stroke = StrokePaintManager.Server;
        shape.StrokeWidth = StrokeWidth;
        shape.StrokeLinecap = StrokeLinecap;
        shape.StrokeLinejoin = StrokeLinejoin;

        return shape;
    }

    private void DeleteSelected() {
        if (SelectedShape != null) {
            Canvas.Shapes.Remove(SelectedShape);
            SelectedShape = null;
        }
    }

    private void Select(Shape shape) {
        SelectedShape = shape;
        IsOperatingOnShape = true;
    }

    private void ProcessSelection() {
        // TODO is it possible to stop event bubble? If so, this could be handled on anchor mouse up / mouse shape up
        if (IsOperatingOnShape) {
            if (IsSelected && Canvas.IsDragging) {
                if (IsOperatingOnAnchor) {
                    SelectedAnchor.Set(SelectedShape, Canvas.SnappedEndPoint);
                }
                else {
                    SelectedShape.Transform(Canvas.Delta, Canvas.SnapToGrid, Canvas.GridSize);
                }
            }
        }
        else {
            SelectedShape = null;
        }
    }

    private void Deselect() {
        SelectedShape = null;
    }

    private void ApplyFill() {
        if (IsSelected) {
            SelectedShape.Fill = FillPaintManager.Server;
        }
    }

    private void ApplyStroke() {
        if (IsSelected) {
            SelectedShape.Stroke = StrokePaintManager.Server;
        }
    }

    private void ApplyStrokeLinecap() {
        if (IsSelected) {
            SelectedShape.StrokeLinecap = StrokeLinecap;
        }
    }


    private void ApplyStrokeLinejoin() {
        if (IsSelected) {
            SelectedShape.StrokeLinejoin = StrokeLinejoin;
        }
    }

    private void ApplyStrokeWidth() {
        if (IsSelected) {
            SelectedShape.StrokeWidth = StrokeWidth;
        }
    }

    private void MoveSelectedShapeToBackOfList() {
        if (IsSelected) {
            Canvas.Shapes.Remove(SelectedShape);
            Canvas.Shapes.Insert(0, SelectedShape);
        }
    }

    private void MoveSelectedShapeInList(int indexChange) {
        if (IsSelected) {
            var index = Canvas.Shapes.IndexOf(SelectedShape);
            var newIndex = index + indexChange;

            if (newIndex > 0 && newIndex < Canvas.Shapes.Count) {
                Canvas.Shapes[index] = Canvas.Shapes[newIndex];
                Canvas.Shapes[newIndex] = SelectedShape;
            }
        }
    }

    private void MoveSelectedShapeToFrontOfList() {
        if (IsSelected) {
            Canvas.Shapes.Remove(SelectedShape);
            Canvas.Shapes.Add(SelectedShape);
        }
    }

    private async Task Save() {
        var element = Canvas.ExportSvg();

        await ModuleReference.InvokeVoidAsync("downloadFile", FileName ?? $"graphics {DateTime.UtcNow:yyyyMMdd hhmm}.svg", "image/svg+xml", Encoding.UTF8.GetBytes(element.ToString()));
    }

    private void ToggleLoadModal(bool showLoadModal) {
        ShowLoadModal = showLoadModal;
        FileLoadError = null;
        FileToLoad = null;
    }

    private void OnInputFileToLoadChange(InputFileChangeEventArgs e) {
        // TODO clear input as well
        FileToLoad = e.File;
    }

    private async Task Load() {
        if (FileToLoad == null) {
            FileLoadError = "Please provide a valid SVG file.";
            return;
        }

        var data = await new StreamReader(FileToLoad.OpenReadStream()).ReadToEndAsync();
        var deserializationResult = SvgFileParser.Parse(data);

        if (deserializationResult.IsSuccess) {
            FileName = Path.GetFileName(FileToLoad.Name);
            Canvas = deserializationResult.Canvas;
            ToggleLoadModal(false);
        }
        else {
            FileLoadError = deserializationResult.ErrorMessage;
        }
    }
}
