@page "/graphics"
@using BlazorPlayground.Graphics
@using System.Globalization
@using System.Xml.Linq
@using System.Text
@using System.IO
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<h1>Graphics</h1>

<div class="modal graphics-modal @(ShowLoadModal ? "d-block" : "")" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Load file</h5>
                <button type="button" class="btn-close" aria-label="Close" @onclick="() => ToggleLoadModal(false)"></button>
            </div>
            <div class="modal-body">
                <p>Please note that only valid SVG files can be parsed and only Canvas.Shapes written by this graphics module can be edited.</p>

                <label for="inputFileToLoad" class="form-label">SVG file</label>
                <InputFile id="inputFileToLoad" class="@(FileLoadHasError ? "form-control is-invalid" : "form-control")" OnChange="OnInputFileToLoadChange" />

                @if (FileLoadHasError) {
                    <div class="invalid-feedback">@FileLoadError</div>
                }
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" @onclick="Load">Load</button>
                <button type="button" class="btn btn-secondary" @onclick="() => ToggleLoadModal(false)">Cancel</button>
            </div>
        </div>
    </div>
</div>

<ul class="nav nav-tabs mb-3">
    <li class="nav-item">
        <a class="nav-link @(Canvas.IsDrawing ? "" : "active")" @onclick="() => Canvas.StopDrawing()">Select</a>
    </li>

    @foreach (var definition in ShapeDefinition.Values) {
        <li class="nav-item">
            <a class="nav-link @(Canvas.IsDrawing && Canvas.CurrentShapeDefinition == definition ? "active" : "")" @onclick="() => Canvas.StartDrawing(definition)">@definition.Name</a>
        </li>
    }
</ul>

<div class="mb-3 graphics-ribbon">
    <div class="btn-toolbar">
        <div class="btn-group mb-3 me-3">
            <button type="button" class="btn btn-secondary" @onclick="() => Save()">Save</button>
            <button type="button" class="btn btn-secondary" @onclick="() => ToggleLoadModal(true)">Load</button>
        </div>

        @*TODO hide settings that are not applicable*@

        <div class="input-group mb-3 me-3">
            <label for="fillColor" class="input-group-text">Fill</label>

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeColor" @onclick="() => Canvas.DrawSettings.FillPaintManager.Mode = PaintMode.Color" checked="@(Canvas.DrawSettings.FillPaintManager.Mode == PaintMode.Color)" />
                <label class="form-check-label ps-2" for="fillPaintModeColor">Color</label>
            </div>

            <input type="text" class="form-control" id="fillColor" style="background-color: @Canvas.DrawSettings.FillPaintManager.Color; color: @Canvas.DrawSettings.FillPaintManager.Color.ContrastingColor" @bind-value="Canvas.DrawSettings.FillPaintManager.ColorValue" />

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="fillPaintMode" id="fillPaintModeNone" @onclick="() => Canvas.DrawSettings.FillPaintManager.Mode = PaintMode.None" checked="@(Canvas.DrawSettings.FillPaintManager.Mode == PaintMode.None)" />
                <label class="form-check-label ps-2" for="fillPaintModeNone">None</label>
            </div>

            @if (!Canvas.IsDrawing) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyFill()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeColor" class="input-group-text">Stroke</label>

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeColor" @onclick="() => Canvas.DrawSettings.StrokePaintManager.Mode = PaintMode.Color" checked="@(Canvas.DrawSettings.StrokePaintManager.Mode == PaintMode.Color)" />
                <label class="form-check-label ps-2" for="strokePaintModeColor">Color</label>
            </div>

            <input type="text" class="form-control" id="strokeColor" style="background-color: @Canvas.DrawSettings.StrokePaintManager.Color; color: @Canvas.DrawSettings.StrokePaintManager.Color.ContrastingColor" @bind-value="Canvas.DrawSettings.StrokePaintManager.ColorValue" />

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="radio" name="strokePaintMode" id="strokePaintModeNone" @onclick="() => Canvas.DrawSettings.StrokePaintManager.Mode = PaintMode.None" checked="@(Canvas.DrawSettings.StrokePaintManager.Mode == PaintMode.None)" />
                <label class="form-check-label ps-2" for="strokePaintModeNone">None</label>
            </div>

            @if (!Canvas.IsDrawing) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStroke()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeWidth" class="input-group-text">Stroke width</label>
            <input type="text" class="form-control" id="strokeWidth" @bind-value="Canvas.DrawSettings.StrokeWidth" />

            @if (!Canvas.IsDrawing) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeWidth()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeLinecap" class="input-group-text">Linecap</label>

            <select class="form-select" id="strokeLinecap" @bind="Canvas.DrawSettings.StrokeLinecap">
                @foreach (var linecap in Enum.GetValues<Linecap>()) {
                    <option value="@linecap">@linecap</option>
                }
            </select>

            @if (!Canvas.IsDrawing) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinecap()">Apply</button>
            }
        </div>

        <div class="input-group mb-3 me-3">
            <label for="strokeLinejoin" class="input-group-text">Linejoin</label>

            <select class="form-select" id="strokeLinejoin" @bind="Canvas.DrawSettings.StrokeLinejoin">
                @foreach (var linejoin in Enum.GetValues<Linejoin>()) {
                    <option value="@linejoin">@linejoin</option>
                }
            </select>

            @if (!Canvas.IsDrawing) {
                <button type="button" class="btn btn-secondary" @onclick="() => ApplyStrokeLinejoin()">Apply</button>
            }
        </div>

        @if (!Canvas.IsDrawing) {
            <div class="btn-group mb-3 me-3">
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToFrontOfList()">Move to front</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(1)">Move forward</button>
            </div>

            <div class="btn-group mb-3 me-3">
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeInList(-1)">Move backward</button>
                <button type="button" class="btn btn-secondary" @onclick="() => MoveSelectedShapeToBackOfList()">Move to back</button>
            </div>

            <div class="btn-group mb-3 me-3">
                <button type="button" class="btn btn-secondary" @onclick="() => Canvas.DeleteSelectedShape()">Delete</button>
            </div>
        }
        else {
            @*TODO hide if not applicable*@
            <div class="input-group mb-3 me-3">
                <label for="regularPolygonSides" class="input-group-text">Sides</label>
                <input type="text" class="form-control" id="regularPolygonSides" @bind-value="Canvas.DrawSettings.Sides" />
            </div>
        }

        <div class="input-group mb-3 me-3">
            <label for="canvasWidth" class="input-group-text">Width</label>
            <input type="text" class="form-control" id="canvasWidth" @bind-value="Canvas.Width" />
        </div>

        <div class="input-group mb-3 me-3">
            <label for="canvasHeight" class="input-group-text">Height</label>
            <input type="text" class="form-control" id="canvasHeight" @bind-value="Canvas.Height" />
        </div>

        <div class="input-group mb-3">
            <label for="gridSize" class="input-group-text">Grid size</label>
            <input type="text" class="form-control" id="gridSize" @bind-value="Canvas.GridSize" />

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="checkbox" id="showGrid" @bind="Canvas.ShowGrid" />
                <label class="form-check-label ps-2" for="showGrid">Show</label>
            </div>

            <div class="input-group-text">
                <input class="form-check-input mt-0" type="checkbox" id="snapToGrid" @bind="Canvas.SnapToGrid" />
                <label class="form-check-label ps-2" for="snapToGrid">Snap</label>
            </div>
        </div>
    </div>
</div>

<svg class="graphics-main" viewBox="0 0 @Canvas.Width @Canvas.Height" width="@Canvas.Width" height="@Canvas.Height" @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnCanvasMouseUp">
    @if (Canvas.ShowGrid) {
        for (var x = Canvas.GridSize; x < Canvas.Width; x += Canvas.GridSize) {
            <line class="grid-line" x1="@x" y1="0" x2="@x" y2="@Canvas.Height" />
        }

        for (var y = Canvas.GridSize; y < Canvas.Height; y += Canvas.GridSize) {
            <line class="grid-line" x1="0" y1="@y" x2="@Canvas.Width" y2="@y" />
        }
    }

    @foreach (var shape in Canvas.Shapes) {
        if (shape == Canvas.SelectedShape) {
            if (Canvas.IsExecutingAction) {
                var virtualShape = Canvas.CreateVirtualSelectedShape();

                <ShapeRenderer Shape="virtualShape" IsVirtual="true" OnMouseUp="args => OnShapeMouseUp(args, shape)" />

                foreach (var anchor in virtualShape.Anchors) {
                    var point = anchor.Get(virtualShape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" @onmouseup="args => OnAnchorMouseUp(args, anchor)" @onmouseup:stopPropagation="true" />
                }
            }
            else {
                <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="true" OnMouseUp="args => OnShapeMouseUp(args, shape)" />

                foreach (var anchor in shape.Anchors) {
                    var point = anchor.Get(shape);

                    <rect class="shape-anchor" x="@((point.X - 5).ToString(CultureInfo.InvariantCulture))" y="@((point.Y - 5).ToString(CultureInfo.InvariantCulture))" width="10" height="10" @onmousedown="args => OnAnchorMouseDown(args, anchor)" />
                }
            }
        }
        else {
            <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="false" />
        }
    }

    @if (Canvas.IsDrawing && Canvas.IsExecutingAction) {
        <ShapeRenderer Shape="Canvas.CreateShape()" IsVirtual="true" />
    }
</svg>

@code {
    private IJSObjectReference ModuleReference { get; set; }
    private bool ShowLoadModal { get; set; } = false;
    private string FileLoadError { get; set; }
    private bool FileLoadHasError => !string.IsNullOrWhiteSpace(FileLoadError);
    private IBrowserFile FileToLoad { get; set; }
    private string FileName { get; set; }
    private Canvas Canvas { get; set; } = new Canvas();

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            ModuleReference = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/downloadFile.js");
        }
    }

    public async ValueTask DisposeAsync() {
        if (ModuleReference is not null) {
            await ModuleReference.DisposeAsync();
        }
    }

    private void OnCanvasMouseDown(MouseEventArgs args) {
        if (args.Button == 0) {
            Canvas.StartPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs args) {
        if (args.Button == 0 && Canvas.StartPoint != null) {
            Canvas.EndPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs args) {
        if (args.Button == 0) {
            if (Canvas.IsDrawing && Canvas.IsExecutingAction) {
                Canvas.AddShape();
            }
            else {
                Canvas.SelectedShape = null;
            }

            Canvas.ClearActionExecution();
        }
    }

    private void OnShapeMouseDown(MouseEventArgs args, Shape shape) {
        if (!Canvas.IsDrawing && args.Button == 0) {
            // TODO set correct definition after selecting
            Canvas.SelectedShape = shape;
        }
    }

    private void OnShapeMouseUp(MouseEventArgs args, Shape shape) {
        if (args.Button == 0) {
            Canvas.TransformSelectedShape();
        }
    }

    private void OnAnchorMouseDown(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            Canvas.SelectedAnchor = anchor;
        }
    }

    private void OnAnchorMouseUp(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            Canvas.TransformSelectedShapeAnchor();
        }    
    }

    private void ApplyFill() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.Fill = Canvas.DrawSettings.FillPaintManager.Server;
        }
    }

    private void ApplyStroke() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.Stroke = Canvas.DrawSettings.StrokePaintManager.Server;
        }
    }

    private void ApplyStrokeLinecap() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.StrokeLinecap = Canvas.DrawSettings.StrokeLinecap;
        }
    }

    private void ApplyStrokeLinejoin() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.StrokeLinejoin = Canvas.DrawSettings.StrokeLinejoin;
        }
    }

    private void ApplyStrokeWidth() {
        if (Canvas.SelectedShape != null) {
            Canvas.SelectedShape.StrokeWidth = Canvas.DrawSettings.StrokeWidth;
        }
    }

    private void MoveSelectedShapeToBackOfList() {
        if (Canvas.SelectedShape != null) {
            Canvas.Shapes.Remove(Canvas.SelectedShape);
            Canvas.Shapes.Insert(0, Canvas.SelectedShape);
        }
    }

    private void MoveSelectedShapeInList(int indexChange) {
        if (Canvas.SelectedShape != null) {
            var index = Canvas.Shapes.IndexOf(Canvas.SelectedShape);
            var newIndex = index + indexChange;

            if (newIndex > 0 && newIndex < Canvas.Shapes.Count) {
                Canvas.Shapes[index] = Canvas.Shapes[newIndex];
                Canvas.Shapes[newIndex] = Canvas.SelectedShape;
            }
        }
    }

    private void MoveSelectedShapeToFrontOfList() {
        if (Canvas.SelectedShape != null) {
            Canvas.Shapes.Remove(Canvas.SelectedShape);
            Canvas.Shapes.Add(Canvas.SelectedShape);
        }
    }

    private async Task Save() {
        var element = Canvas.ExportSvg();

        await ModuleReference.InvokeVoidAsync("downloadFile", FileName ?? $"graphics {DateTime.UtcNow:yyyyMMdd hhmm}.svg", "image/svg+xml", Encoding.UTF8.GetBytes(element.ToString()));
    }

    private void ToggleLoadModal(bool showLoadModal) {
        ShowLoadModal = showLoadModal;
        FileLoadError = null;
        FileToLoad = null;
    }

    private void OnInputFileToLoadChange(InputFileChangeEventArgs e) {
        // TODO clear input as well
        FileToLoad = e.File;
    }

    private async Task Load() {
        if (FileToLoad == null) {
            FileLoadError = "Please provide a valid SVG file.";
            return;
        }

        var data = await new StreamReader(FileToLoad.OpenReadStream()).ReadToEndAsync();
        var deserializationResult = SvgFileParser.Parse(data);

        if (deserializationResult.IsSuccess) {
            FileName = Path.GetFileName(FileToLoad.Name);
            Canvas = deserializationResult.Canvas;
            ToggleLoadModal(false);
        }
        else {
            FileLoadError = deserializationResult.ErrorMessage;
        }
    }
}
