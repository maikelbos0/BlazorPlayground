@page "/graphics"
@using BlazorPlayground.Graphics

<h1>Graphics</h1>

<ul class="nav nav-tabs mb-3">
    @foreach (var actionType in Enum.GetValues<ActionType>()) {
        <li class="nav-item">
            <a class="nav-link @(currentActionType == actionType ? "active" : "")" @onclick="() => SwitchActionType(actionType)">@actionDefinitions[actionType].Name</a>
        </li>
    }
</ul>

<div class="mb-3 graphics-ribbon">
    <div class="btn-toolbar">
        @if (currentActionType == ActionType.Select) {
            <div class="button-group mb-3">
                <button type="button" class="btn btn-secondary" @onclick="DeleteSelected">Delete</button>
            </div>
        }
        else if (currentActionType == ActionType.DrawLine) {

        }
        else if (currentActionType == ActionType.DrawRectangle) {

        }
        else if (currentActionType == ActionType.DrawRegularPolygon) {
            <div class="input-group mb-3">
                <div class="input-group-prepend">
                    <label for="regularPolygonSides" class="input-group-text">Sides</label>
                </div>
                <input type="text" class="form-control" id="regularPolygonSides" @bind-value="RegularPolygonSides" />
            </div>
        }
        else if (currentActionType == ActionType.CanvasSettings) {
            <div class="input-group mb-3 me-3">
                <div class="input-group-prepend">
                    <label for="canvasWidth" class="input-group-text">Width</label>
                </div>
                <input type="text" class="form-control" id="canvasWidth" @bind-value="CanvasWidth" />
            </div>

            <div class="input-group mb-3 me-3">
                <div class="input-group-prepend">
                    <label for="canvasHeight" class="input-group-text">Height</label>
                </div>
                <input type="text" class="form-control" id="canvasHeight" @bind-value="CanvasHeight" />
            </div>

            <div class="input-group mb-3">
                <div class="input-group-prepend">
                    <label for="gridSize" class="input-group-text">Grid size</label>
                </div>
                <input type="text" class="form-control" id="gridSize" @bind-value="GridSize" />

                <div class="input-group-text">
                    <input class="form-check-input mt-0 me-2" type="checkbox" id="showGrid" @bind="showGrid">
                    <label class="form-check-label" for="showGrid">Show</label>
                </div>

                <div class="input-group-text">
                    <input class="form-check-input mt-0 me-2" type="checkbox" id="snapToGrid" @bind="snapToGrid">
                    <label class="form-check-label" for="snapToGrid">Snap</label>
                </div>
            </div>
        }
    </div>
</div>

<svg class="graphics-main" viewBox="0 0 @canvasWidth @canvasHeight" style="width: @(canvasWidth)px; height: @(canvasHeight)px" @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnCanvasMouseUp">
    @if (showGrid) {
        for (var x = gridSize; x < canvasWidth; x += gridSize) {
            <line class="grid-line" x1="@x" y1="0" x2="@x" y2="@canvasHeight" />
        }

        for (var y = gridSize; y < canvasHeight; y += gridSize) {
            <line class="grid-line" x1="0" y1="@y" x2="@canvasWidth" y2="@y" />
        }
    }

    @foreach (var shape in shapes) {
        if (shape == selectedShape) {
            if (isObjectClicked && currentPoint != null) {
                var changingShape = selectedShape.Clone();

                if (currentAnchor != null) {
                    currentAnchor.Set(changingShape, GetSnappedPoint(currentPoint));
                }
                else {
                    var delta = currentPoint - startPoint;

                    if (snapToGrid) {
                        var point = changingShape.Anchors
                            .Select(a => a.Get(changingShape))
                            .Select(p => new { Original = p, Transformed = p + delta, Anchored = (p + delta).SnapToGrid(GridSize) })
                            .OrderBy(p => (p.Transformed - p.Anchored).Distance)
                            .First();

                        delta = point.Anchored - point.Original;
                    }

                    changingShape.Transform(delta);
                }

                <ShapeRenderer Shape="changingShape" IsVirtual="true" />

                foreach (var anchor in changingShape.Anchors) {
                    var point = anchor.Get(changingShape);

                    <rect class="shape-anchor" x="@(point.X - 5)" y="@(point.Y - 5)" width="10" height="10" />
                }
            }
            else {
                <ShapeRenderer @key="selectedShape" Shape="selectedShape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="true" />

                foreach (var anchor in selectedShape.Anchors) {
                    var point = anchor.Get(selectedShape);

                    <rect class="shape-anchor" x="@(point.X - 5)" y="@(point.Y - 5)" width="10" height="10" @onmousedown="args => OnAnchorMouseDown(args, anchor)" />
                }
            }
        }
        else {
            <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="false" />
        }
    }

    @if (currentPoint != null && CurrentActionDefinition is DrawActionDefinition drawActionDefinition) {
        <ShapeRenderer Shape="drawActionDefinition.CreateShape(this, CreateCoordinates(currentPoint))" IsVirtual="true" />
    }
</svg>

@code {

    private enum ActionType {
        Select,
        DrawLine,
        DrawRectangle,
        DrawRegularPolygon,
        CanvasSettings
    }

    private record ActionCoordinates(Point StartPoint, Point SnappedStartPoint, Point EndPoint, Point SnappedEndPoint);

    private class ActionDefinition {
        public string Name { get; }
        public Action<Graphics, ActionCoordinates> OnCanvasMouseUp { get; }
        public Action<Graphics, Shape> OnShapeMouseDown { get; }
        public Action<Graphics> OnSwitchFrom { get; }

        public ActionDefinition(
            string name,
            Action<Graphics, ActionCoordinates> onCanvasMouseUp = null,
            Action<Graphics, Shape> onShapeMouseDown = null,
            Action<Graphics> onSwitchFrom = null
        ) {
            Name = name;
            OnCanvasMouseUp = onCanvasMouseUp ?? ((_, _) => { });
            OnShapeMouseDown = onShapeMouseDown ?? ((_, _) => { });
            OnSwitchFrom = onSwitchFrom ?? (_ => { });
        }
    }

    private class DrawActionDefinition : ActionDefinition {
        public Func<Graphics, ActionCoordinates, Shape> CreateShape { get; }

        public DrawActionDefinition(string name, Func<Graphics, ActionCoordinates, Shape> createShape)
            : base(name, (graphics, coordinates) => graphics.AddShape(coordinates, createShape)) {
            CreateShape = createShape;
        }
    }

    private static Dictionary<ActionType, ActionDefinition> actionDefinitions = new Dictionary<ActionType, ActionDefinition>() {
        { ActionType.Select, new ActionDefinition("Select", onCanvasMouseUp: (graphics, coordinates) => graphics.ProcessSelection(coordinates), onShapeMouseDown: (graphics, shape) => graphics.Select(shape), onSwitchFrom: graphics => graphics.Deselect()) },
        { ActionType.DrawLine, new DrawActionDefinition("Line", (graphics, coordinates) => new Line(coordinates.SnappedStartPoint, coordinates.SnappedEndPoint)) },
        { ActionType.DrawRectangle, new DrawActionDefinition("Rectangle", (graphics, coordinates) => new Rectangle(coordinates.SnappedStartPoint, coordinates.SnappedEndPoint)) },
        { ActionType.DrawRegularPolygon, new DrawActionDefinition("Regular polygon", (graphics, coordinates) => new RegularPolygon(coordinates.SnappedStartPoint, coordinates.SnappedEndPoint, graphics.regularPolygonSides)) },
        { ActionType.CanvasSettings, new ActionDefinition("Canvas settings") }
    };

    private List<Shape> shapes = new List<Shape>();
    private ActionType currentActionType = ActionType.DrawRegularPolygon;
    private Point startPoint;
    private Point currentPoint;
    private int regularPolygonSides = 3;
    private Shape selectedShape;
    private bool isObjectClicked = false;
    private Anchor currentAnchor;
    private int canvasWidth = 800;
    private int canvasHeight = 800;
    private int gridSize = 50;
    private bool showGrid = false;
    private bool snapToGrid = false;

    private ActionDefinition CurrentActionDefinition => actionDefinitions[currentActionType];

    private int RegularPolygonSides {
        get => regularPolygonSides;
        set => regularPolygonSides = Math.Max(value, 3);
    }

    private int CanvasWidth {
        get => canvasWidth;
        set => canvasWidth = Math.Max(value, 1);
    }

    private int CanvasHeight {
        get => canvasHeight;
        set => canvasHeight = Math.Max(value, 1);
    }

    private int GridSize {
        get => gridSize;
        set => gridSize = Math.Max(value, 1);
    }

    private void SwitchActionType(ActionType newActionType) {
        CurrentActionDefinition.OnSwitchFrom(this);
        currentActionType = newActionType;
    }

    private void OnCanvasMouseDown(MouseEventArgs args) {
        if (args.Button == 0) {
            startPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs args) {
        if (args.Button == 0 && startPoint != null) {
            currentPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs args) {
        if (args.Button == 0 && startPoint != null) {
            CurrentActionDefinition.OnCanvasMouseUp(this, CreateCoordinates(new Point(args.OffsetX, args.OffsetY)));
        }

        startPoint = null;
        currentPoint = null;
        currentAnchor = null;
        isObjectClicked = false;
    }

    private void OnShapeMouseDown(MouseEventArgs args, Shape shape) {
        if (args.Button == 0) {
            CurrentActionDefinition.OnShapeMouseDown(this, shape);
        }
    }

    private void OnAnchorMouseDown(MouseEventArgs args, Anchor anchor) {
        if (args.Button == 0) {
            currentAnchor = anchor;
            isObjectClicked = true;
        }
    }

    private ActionCoordinates CreateCoordinates(Point endPoint) =>
        new ActionCoordinates(startPoint, GetSnappedPoint(startPoint), endPoint, GetSnappedPoint(endPoint));

    private Point GetSnappedPoint(Point point) {
        if (!snapToGrid || point == null) {
            return point;
        }

        return point.SnapToGrid(gridSize);
    }

    private void AddShape(ActionCoordinates coordinates, Func<Graphics, ActionCoordinates, Shape> createShape) {
        if (HasMetMinimumDistanceRequirement(coordinates)) {
            shapes.Add(createShape(this, coordinates));
        }
    }

    private bool HasMetMinimumDistanceRequirement(ActionCoordinates coordinates)
        => (coordinates.SnappedStartPoint - coordinates.SnappedEndPoint).Distance > 5;

    private void DeleteSelected() {
        if (selectedShape != null) {
            shapes.Remove(selectedShape);
            selectedShape = null;
        }
    }

    private void Select(Shape shape) {
        selectedShape = shape;
        isObjectClicked = true;
    }

    private void ProcessSelection(ActionCoordinates coordinates) {
        if (isObjectClicked && selectedShape != null && currentPoint != null) {
            if (currentAnchor != null) {
                currentAnchor.Set(selectedShape, coordinates.SnappedEndPoint);
            }
            else {
                var delta = coordinates.EndPoint - coordinates.StartPoint;

                if (snapToGrid) {
                    var point = selectedShape.Anchors
                        .Select(a => a.Get(selectedShape))
                        .Select(p => new { Original = p, Transformed = p + delta, Anchored = (p + delta).SnapToGrid(GridSize) })
                        .OrderBy(p => (p.Transformed - p.Anchored).Distance)
                        .First();

                    delta = point.Anchored - point.Original;
                }

                selectedShape.Transform(delta);
            }
        }
        else {
            selectedShape = null;
        }
    }

    private void Deselect() {
        selectedShape = null;
    }
}
