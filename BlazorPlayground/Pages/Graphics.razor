@page "/graphics"
@using BlazorPlayground.Graphics

<h1>Graphics</h1>

<ul class="nav nav-tabs mb-3">
    @foreach (var actionType in Enum.GetValues<ActionType>()) {
        <li class="nav-item">
            <a class="nav-link @(currentActionType == actionType ? "active" : "")" @onclick="() => SwitchActionType(actionType)">@actionDefinitions[actionType].Name</a>
        </li>
    }
</ul>

<div class="mb-3 graphics-ribbon">
    <div class="btn-toolbar">
        @if (currentActionType == ActionType.Select) {
            <div class="button-group mb-3">
                <button type="button" class="btn btn-secondary" @onclick="DeleteSelected">Delete</button>
            </div>
        }
        else if (currentActionType == ActionType.DrawLine) {

        }
        else if (currentActionType == ActionType.DrawRectangle) {

        }
        else if (currentActionType == ActionType.DrawRegularPolygon) {
            <div class="input-group mb-3">
                <div class="input-group-prepend">
                    <label for="regularPolygonSides" class="input-group-text">Sides</label>
                </div>
                <input type="text" class="form-control" id="regularPolygonSides" @bind-value="RegularPolygonSides" />
            </div>
        }
    </div>
</div>

<svg class="graphics-main" @onmousedown="OnCanvasMouseDown" @onmousemove="OnCanvasMouseMove" @onmouseup="OnCanvasMouseUp">
    @foreach (var shape in shapes) {
        if (shape == selectedShape && startPoint != null && currentPoint != null && HasMetMinimumDistanceRequirement(currentPoint)) {
            var movingShape = shape.Clone();
            
            movingShape.Transform(currentPoint - startPoint);

            <ShapeRenderer Shape="movingShape" IsVirtual="true" />
        }
        else {
            <ShapeRenderer @key="shape" Shape="shape" OnMouseDown="args => OnShapeMouseDown(args, shape)" IsSelected="shape == selectedShape" />
        }
    }

    @if (startPoint != null && currentPoint != null && CurrentActionDefinition is DrawActionDefinition drawActionDefinition) {
        <ShapeRenderer @key="startPoint" Shape="drawActionDefinition.CreateShape(this, currentPoint)" IsVirtual="true" />
    }
</svg>

@code {

    private enum ActionType {
        Select,
        DrawLine,
        DrawRectangle,
        DrawRegularPolygon
    }

    private class ActionDefinition {
        public string Name { get; }
        public Action<Graphics, Point> OnCanvasMouseUp { get; }
        public Action<Graphics, Shape> OnShapeMouseDown { get; }
        public Action<Graphics> OnSwitchFrom { get; }

        public ActionDefinition(
            string name,
            Action<Graphics, Point> onCanvasMouseUp = null,
            Action<Graphics, Shape> onShapeMouseDown = null,
            Action<Graphics> onSwitchFrom = null
        ) {
            Name = name;
            OnCanvasMouseUp = onCanvasMouseUp ?? ((_, _) => { });
            OnShapeMouseDown = onShapeMouseDown ?? ((_, _) => { });
            OnSwitchFrom = onSwitchFrom ?? (_ => { });
        }
    }

    private class DrawActionDefinition : ActionDefinition {
        public Func<Graphics, Point, Shape> CreateShape { get; }

        public DrawActionDefinition(string name, Func<Graphics, Point, Shape> createShape)
            : base(name, (graphics, endPoint) => graphics.AddShape(endPoint, createShape)) {
            CreateShape = createShape;
        }
    }

    private static Dictionary<ActionType, ActionDefinition> actionDefinitions = new Dictionary<ActionType, ActionDefinition>() {
        { ActionType.Select, new ActionDefinition("Select", onCanvasMouseUp: (graphics, endPoint) => graphics.ProcessSelection(endPoint), onShapeMouseDown: (graphics, shape) => graphics.Select(shape), onSwitchFrom: graphics => graphics.Deselect()) },
        { ActionType.DrawLine, new DrawActionDefinition("Line", (graphics, endPoint) => new Line(graphics.startPoint, endPoint)) },
        { ActionType.DrawRectangle, new DrawActionDefinition("Rectangle", (graphics, endPoint) => new Rectangle(graphics.startPoint, endPoint)) },
        { ActionType.DrawRegularPolygon, new DrawActionDefinition("Regular polygon", (graphics, endPoint) => new RegularPolygon(graphics.startPoint, endPoint, graphics.regularPolygonSides)) }
    };

    private List<Shape> shapes = new List<Shape>();
    private ActionType currentActionType = ActionType.DrawRegularPolygon;
    private Point startPoint;
    private Point currentPoint;
    private int regularPolygonSides = 3;
    private Shape selectedShape;    
    private bool isSelecting = false;

    private ActionDefinition CurrentActionDefinition => actionDefinitions[currentActionType];

    private int RegularPolygonSides {
        get => regularPolygonSides;
        set => regularPolygonSides = Math.Max(value, 3);
    }

    private void SwitchActionType(ActionType newActionType) {
        CurrentActionDefinition.OnSwitchFrom(this);
        currentActionType = newActionType;
    }

    private void OnCanvasMouseDown(MouseEventArgs args) {
        if (args.Button == 0) {
            startPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseMove(MouseEventArgs args) {
        if (args.Button == 0) {
            currentPoint = new Point(args.OffsetX, args.OffsetY);
        }
    }

    private void OnCanvasMouseUp(MouseEventArgs args) {
        if (args.Button == 0) {
            CurrentActionDefinition.OnCanvasMouseUp(this, new Point(args.OffsetX, args.OffsetY));
            startPoint = null;
            currentPoint = null;
        }
    }

    private void OnShapeMouseDown(MouseEventArgs args, Shape shape) {
        if (args.Button == 0) {
            CurrentActionDefinition.OnShapeMouseDown(this, shape);
        }
    }

    private void AddShape(Point endPoint, Func<Graphics, Point, Shape> createShape) {
        if (HasMetMinimumDistanceRequirement(endPoint)) {
            shapes.Add(createShape(this, endPoint));
        }
    }

    private bool HasMetMinimumDistanceRequirement(Point endPoint)
        => startPoint - endPoint > 5;

    private void DeleteSelected() {
        if (selectedShape != null) {
            shapes.Remove(selectedShape);
            selectedShape = null;
        }
    }

    private void Select(Shape shape) {
        selectedShape = shape;
        isSelecting = true;
    }

    private void ProcessSelection(Point endPoint) {
        if (selectedShape != null && HasMetMinimumDistanceRequirement(endPoint)) {
            Move(endPoint);
        }
        else {
            Deselect();
        }

        isSelecting = false;
    }

    private void Deselect() {
        if (!isSelecting) {
            selectedShape = null;
        }
    }

    private void Move(Point endPoint) {
        if (selectedShape != null) {
            selectedShape.Transform(endPoint - startPoint);
        }
    }
}
